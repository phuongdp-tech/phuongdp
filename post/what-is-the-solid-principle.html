<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9PVHR7FRM2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-9PVHR7FRM2');
    </script>
    <meta charset="utf-8" />
    <title>Winzone blog - Cơ bản về nguyên lý thiết kế SOLID</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Winzone blog - Sharing knowledge, together we win" />
    <meta name="keywords" content="HTML, CSS, SQL, JAVA, SPRING, BLOCKCHAIN, SOLIDITY, RUST" />
    <meta name="author" content="PhuongDP" />
    <!-- favicon -->
    <link rel="shortcut icon" href="../images/favicon.ico">
    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <!-- Icons -->
    <link href="../css/materialdesignicons.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>

    <!-- Main Css -->
    <link href="../css/style.css" rel="stylesheet" type="text/css" id="theme-opt" />
    <link href="../css/colors/green.css" rel="stylesheet" id="color-opt">
</head>

<body>
<!-- Loader -->
<!--<div id="preloader">-->
<!--    <div id="status">-->
<!--        <div class="spinner">-->
<!--            <div class="double-bounce1"></div>-->
<!--            <div class="double-bounce2"></div>-->
<!--        </div>-->
<!--    </div>-->
<!--</div>-->
<!-- Loader -->
<div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/vi_VN/sdk.js#xfbml=1&version=v12.0&appId=349033547077915&autoLogAppEvents=1" nonce="a4JaignQ"></script>

<!-- Navbar STart -->
<header id="topnav" class="defaultscroll sticky">

</header><!--end header-->
<!-- Navbar End -->

<!-- Hero Start -->
<section class="bg-half bg-sologan d-table w-100">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-lg-12 text-center">
                <div class="page-next-level">
                    <h1 class="title title-blog-detail">Cơ bản về nguyên lý thiết kế SOLID</h1>
                    <ul class="list-unstyled mt-4">
                        <li class="list-inline-item h6 user text-muted mr-2"><i class="mdi mdi-account"></i> Phuong Dang</li>
                        <li class="list-inline-item h6 date text-muted"><i class="mdi mdi-calendar-check"></i> 02/Mar/2023</li>
                    </ul>
                </div>
            </div>  <!--end col-->
        </div><!--end row-->
    </div> <!--end container-->
</section><!--end section-->
<!-- Hero End -->

<!-- Blog STart -->
<section class="section-two">
    <div class="container">
        <div class="row">
            <div class="col-12">
                <div class="card blog blog-detail shadow rounded">
<!--                    <img src="../images/blog/groupbyinsql.png" class="img-fluid rounded-top" alt="">-->
                    <div class="card-body content">
<!--                        <h6><i class="mdi mdi-tag text-primary mr-1"></i><a href="/sql.html" class="text-primary">SQL</a></h6>-->
                        <section class="table-content rounded">
                            <ol class="code-blue-text mb-0">
<!--                                <li><a href="#what-is-the-solid-principle">SOLID là gì?</a></li>-->
                                <li><a href="#single-responsibility-principle">Single Responsibility Principle (SRP)</a></li>
                                <li><a href="#open-closed-principle">Open Closed Principle (OCP)</a></li>
                                <li><a href="#liskov-substitution-principle">Liskov Substitution Principle (LSP)</a></li>
                                <li><a href="#interface-segregation-principle">Interface Segregation Principle (ISP)</a></li>
                                <li><a href="#dependency-inversion-principle">Dependency Inversion Principle (DIP)</a></li>
                                <li><a href="#summary">Kết luận.</a></li>
                            </ol>
                        </section>
                        <div class="mt-3">
                            <p><strong>Phát triển phần mềm là một môi trường sẽ liên tục thay đổi, để thích nghi được với điều này thì mỗi sản phẩm cần phải có một kiến trúc thiết kế thật tốt. Với nền móng là kiến trúc tốt thì sản phẩm đó sẽ dễ dàng thay đổi và nâng cấp hơn.</strong></p>
                            <p class="caution rounded p-3">
                                <i class="fas fa-exclamation-circle"></i> Trong bài viết này cần các bạn có kiến thức cơ bản về Object Oriented Programming (OOP)
                            </p>
                        </div>
<!--                        <h2 id="what-is-the-solid-principle" class="mt-4">SOLID là gì?</h2>-->
                        <p class="mb-0">
                            SOLID là từ viết tắt kết hợp từ 5 chữ cái đầu tiên của 5 nguyên lý, được đưa ra bởi <b>Bob Martin</b> và <b>Michael Feathers</b>.</p>
                        <ul>
                            <li><b>S</b>ingle Responsibility Principle (SRP)</li>
                            <li><b>O</b>pen Closed Principle (OCP)</li>
                            <li><b>L</b>iskov Substitution Principle (LSP)</li>
                            <li><b>I</b>nterface Segregation Principle (ISP)</li>
                            <li><b>D</b>ependency inversion principle (DIP)</li>
                        </ul>
                        <p>SOLID được coi như là một "must have skill" mà bất cứ software developer nào cũng cần phải biết. Trong bài viết này mình sẽ giới thiệu đến các bạn từng nguyên lý và sử dụng Java để demo.</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/blg_inline_solid_principles.png" alt="SOLID principles">
                            <figcaption><b>Figure 1: SOLID principles</b></figcaption>
                        </figure>

                        <h2 id="single-responsibility-principle" class="mt-4">1. Single Responsibility Principle (SRP)</h2>
                        <p>Nguyên lý đầu tiên có nội dung như sau: </p>
                        <blockquote class="quote rounded mt-3 p-3">
                            <p class="mb-0">Every software component should have one and only one responsibility.</p>
                        </blockquote>
                        <p>Mỗi software component chỉ nên có 1 và chỉ 1 trách nhiệm duy nhất. Trong phạm vi OOP thì chúng ta có thể hiểu software component là: một class, một method hoặc một module. Để hình dung rõ hơn chúng ta cùng xem hình ảnh sau:</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/single-responsibility-principle.png" alt="Single Responsibility Principle (SRP)">
                            <figcaption><b>Figure 2: Single Responsibility Principle (Refer from Accesto.com)</b></figcaption>
                        </figure>
                        <p>Bây giờ thì chắc bạn đã hình dung rõ hơn về khái niệm <code>SRP</code>, nhưng lại thấy khó hiểu rằng đáng ra một component mà làm được nhiều việc như kia thì càng tiết kiệm effort, càng đa năng và đáng ra phải tốt hơn chứ. Tuy nhiên một component mà thực hiện quá nhiều công việc thì dẫn component đó sẽ có <b>nhiều lý do để thay đổi</b>.</p>
                        <p>Việc thay đổi source code trong software development sẽ dẫn đến gia tăng chi phí cũng như tiềm ẩn nhiều rủi ro hoặc bug. Nên khi thiết kế chúng ta luôn cần đảm bảo việc chỉnh sửa cần được thực hiện dễ dàng với phạm vi ảnh hưởng ít nhất có thể. Ví dụ với một class <code>User</code> được thiết kế không tuân thủ <code>SRP</code> như sau: </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/tight_coupling_01.png" alt="tight coupling">
                            <figcaption><b>Figure 3: Class User thiết kế không tuân thủ SRP khi thực hiện 2 nhiệm vụ.</b></figcaption>
                        </figure>
                        <p>Với thiết kế như trên thì class User sẽ có nhiều lý do dẫn đến cần phải thay đổi: </p>
                        <ol>
                            <li>Khi các attribute của user thay đổi, ví dụ: cần quản lý thêm age, hay tách fullName thành firstName và lastName.</li>
                            <li>Khi service mail thay đổi.</li>
                        </ol>

                        <p>Trong trường hợp hệ thống muốn dùng HotMail thay vì Gmail. Điều này dẫn đến class <code>User</code> phải thay đổi để đáp ứng yêu cầu mới. Bây giờ đối chiếu theo nguyên lý <code>SRP</code> ta chỉnh sửa class User như sau: </p>
                        <p></p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/tight_coupling_02.png" alt="loose coupling">
                            <figcaption><b>Figure 4: Hai classes thiết kế tuân thủ SRP khi mỗi class thực hiện 1 nhiệm vụ.</b></figcaption>
                        </figure>
                        <p>Với thiết kế này thì class <code>User</code> không phải thay đối với lý do [2] bên trên nữa, thay vào đó class <code>EmailService</code> sẽ bị thay đổi. <b>Tuy nhiên, vẫn phải thay đổi thì thay đổi ở class User hay class EmailService có gì khác nhau đâu.</b></p>
                        <p>Câu trả lời là có khác nhau. Nếu chúng ta thiết kế theo cách được mô tả ở Figure 3, thì ngoài class <code>User</code> cần send mail thì có thể N những class khác như <code>Ticket</code>, <code>Voucher</code>, <code>Booking</code>... cũng cần send mail. Điều này dẫn đến cũng là thay đổi vì lý do [2], nhưng: </p>
                        <ul>
                            <li>Thiết kế không chuẩn SRP (Figure 3) thì N classes sẽ phải thay đổi</li>
                            <li>Thiết kế chuẩn SRP (Figure 4) thì chỉ EmailService phải thay đổi</li>
                        </ul>
                        <p class="caution rounded p-3">
                            <i class="fas fa-exclamation-circle"></i> Khi mỗi software component chỉ có 1 trách nhiệm thì cũng chỉ có 1 lý do cần thay đổi. Tỉ lệ source phải thay đổi càng ít thì càng dễ thay đổi, tiết kiệm chi phí, giảm thiểu rủi ro.
                        </p>
                        <h2 id="open-closed-principle" class="mt-4">2. Open Closed Principle (OCP)</h2>
                        <p>Nguyên lý này có nội dung như sau: </p>
                        <blockquote class="quote rounded mt-3 p-3">
                            <p class="mb-0">Software components should be close for modification, but open for extension.</p>
                        </blockquote>
                        <p>Có 2 ý chính trong nguyên lý này: </p>
                        <ul>
                            <li><b>Hạn chế sửa đổi (close for modification): </b>Khi thêm các tính năng mới thì hạn chế sửa source của những software component có sẵn</li>
                            <li><b>Ưu tiên mở rộng (open for extension):</b> Khi thêm các tính năng mới thì ưu tiên mở rộng và kế thừa những component đã có sẵn</li>
                        </ul>
                        <p>Để dễ tưởng tượng thì ví dụ bạn có 1 chiếc laptop, tuy nhiên bạn lại không thích bàn phìm trên chiếc laptop đó. Chúng ta sẽ không thể đem chiếc laptop đó ra sửa và lắp loại bàn phím mới vào được, mà thay vào đó hãy setup một chiếc bàn phím ngoài đúng loại mình thích.
                        Vừa lựa chọn được lại bàn phím ưa thích mà không phải sửa gì chiếc laptop. Cũng tương tự như việc: thay lens máy ảnh, dùng loa ngoài cho laptop...</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/ocp_01.jpg" alt="Open Closed Principle">
                            <figcaption><b>Figure 5: External keyboard for laptop.</b></figcaption>
                        </figure>
                        <p>Giả sử chúng ta có một hệ thống bán hàng với chức năng tích điểm thường. Với mỗi đơn hàng, member sẽ được tích điểm thưởng tương đương 1% tổng giá trị đơn hàng. </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/ocp_02.png" alt="Award point">
                            <figcaption><b>Figure 6: Class <code>Member</code>.</b></figcaption>
                        </figure>
                        <p>Nghiệp vụ có thay đổi khi member chia làm 2 loại: <code>normal</code> và <code>platinum</code>. Với normal member thì nghiệp vụ giữ nguyên, tuy nhiên với platinum member thì sẽ tích điểm thưởng tuơng đương 2% tổng giá trị đơn hàng.
                        Để đạt yêu cầu của nghiệp vụ mới ta có thể sửa class <code>Member</code> bằng cách thêm 1 field <code>type</code> và update method <code>incrementAwardPoint()</code> như sau:</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/ocp_03.png" alt="OCP Solution 01">
                            <figcaption><b>Figure 7: Sửa class <code>Member</code> để đạt được nghiệp vụ mới.</b></figcaption>
                        </figure>
                        <p>Tuy nhiên khi chúng ta sửa method <code>incrementAwardPoint()</code>, sẽ tiềm ẩn rủi ro phần tính toán cũ có thể bị sai. Cách sửa trên là chúng ta đang vi phạm vào ý <b>"close for modification"</b>. Ta có 1 phương án mới theo hướng <b>"open for extension"</b> bằng cách
                        tạo ra 1 class mới <code>PlatinumMember</code> và override lại method <code>incrementAwardPoint()</code> để cung cấp 1 cách thức tính mới cho loại member đó. Điều này sẽ giúp chung ta không hề chỉnh sửa vào việc tính toán của xử lý cũ.</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/ocp_04.png" alt="OCP Solution 02">
                            <figcaption><b>Figure 8: Thêm class <code>PlatinumMember</code> để đạt được nghiệp vụ mới.</b></figcaption>
                        </figure>
                        <p class="caution rounded p-3">
                            <i class="fas fa-exclamation-circle"></i> Có thể bạn sẽ thắc mắc là việc chỉnh sửa nhỏ như kia thì có gì rủi ro mà phải phát sinh thêm 1 class mới.
                            Đây chỉ là 1 ví dụ nhỏ để các bạn dễ hình dung hơn về nguyên lý. Còn khi vận dụng thực tế thì chúng ta sẽ cân nhắc phạm vi ảnh hưởng, độ khó để quyết định làm theo solution nào cho hợp lý.
                        </p>
                        <h2 id="liskov-substitution-principle" class="mt-4">3. Liskov Substitution Principle (LSP)</h2>
                        <p>Nguyên lý này có nội dung như sau: </p>
                        <blockquote class="quote rounded mt-3 p-3">
                            <p class="mb-0">Objects should be replaceable with their subtypes without affecting the correctness of the program.</p>
                        </blockquote>
                        <p>Các objects của class con có thể thay thế object của class cha mà vẫn đảm bảo tính đúng đắn của chương trình. Nói cách khác là object của class con có thể làm được tất cả những công việc mà object của class cha có thể làm.</p>
                        <p>Để giải thích rõ hơn chúng ta nói về tính chất kế thừa trong OOP. Tính chất kế thừa thể hiện cho mối quan hệ "is-a", ví dụ:</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/lsp_01.png" alt="is-a">
                            <figcaption><b>Figure 9: Chim cánh cụt và hải âu là 1 loài chim.</b></figcaption>
                        </figure>
                        <p>Với mối quan hệ như trên ta có thể triển khai source code có mối quan hệ kế thừa như sau: </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/lsp_02.png" alt="is-a">
                            <figcaption><b>Figure 10: Class <code>Seagull</code>, <code>Penguin</code> kế thừa <code>Bird</code></b></figcaption>
                        </figure>
                        <p>Bạn có thể thấy vấn đề ở đây là chim cánh cụt thì đúng là 1 loài chim - thỏa mãn "is-a". Nhưng chim cánh cụt có cánh mà lại không thể bay được, dẫn đến nó không thể implement method <code>fly</code> của class cha <code>Bird</code>.
                            Tồn tại 1 unimplemented method thì không phải là cách thiết kế tốt.
                        </p>
                        <p>
                            Nguyên nhân của việc này là do ban đầu người thiết kế cố gắng thực hiện tính kế thừa tuy nhiên lại định nghĩa sai hành vi tổng quát mà trong đó có những class con không thể thực hiện được => Vi phạm nguyên tắc vì "Các objects của class con <span class="text-danger">KHÔNG THỂ</span> thay thế object của class cha".
                            Chúng ta có thể giải quyết vấn đề này như cách bên dưới. Tách hành động <code>fly</code> ra một interface riêng, và chỉ những loài chim nào có thể bay thì implementation
                        </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/lsp_03.png" alt="is-a">
                            <figcaption><b>Figure 11: Tách hành động <code>fly</code> ra một interface riêng, và chỉ những loài chim nào có thể bay thì implementation</b></figcaption>
                        </figure>
                        <h2 id="interface-segregation-principle" class="mt-4">4. Interface Segregation Principle (ISP)</h2>
                        <p>Nguyên lý này có nội dung như sau: </p>
                        <blockquote class="quote rounded mt-3 p-3">
                            <p class="mb-0">No client should be forced to depend on methods it does not use.</p>
                        </blockquote>
                        <p>Nguyên lý này khá dễ hiểu, nó phát biểu rằng những implementation của interface không nên bị phụ thuộc vào những method mà nó không dùng đến. Điều này có nghĩa là chúng ta nên phân chia các method vào những interface hợp lý, không nên nhóm nhiều method vào một FAT interface.</p>
                        <p>Nếu bạn dùng iphone thì liệu Apple có nên tặng kèm 1 một loại dây sạc như này cho bạn không. Tất nhiên là không rồi vì nó dư thừa quá nhiều chức năng không cần thiết.</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/isp_04.png" alt="ISP">
                            <figcaption><b>Figure 12: Một dây sạc dư thừa quá nhiều chức năng cho 1 chiếc iphone.</b></figcaption>
                        </figure>
                        <p>Ví dụ ta có 1 interface <code>IExportable</code> định nghĩa 2 method hỗ trợ export csv hoặc pdf.
                            Tuy nhiên với thông tin sao kê tín dụng <code>CreditStatement</code> thì không hỗ trợ export csv, dẫn đến method <code>exportCsv()</code> sẽ throw exception. Cách thiết kế này đã vi phạm nguyên lý vì <code>CreditStatement</code> đang phải implement một method không liên quan.</p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/isp_01.png" alt="ISP">
                            <figcaption><b>Figure 13: <code>CreditStatement</code> phải implement method không liên quan.</b></figcaption>
                        </figure>
                        <p>Chúng ta có thể sửa bằng cách tách 2 interface như sau. Các class sẽ chọn implement những interface chưa các method mà nó cần thiết. </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/isp_02.png" alt="ISP solution">
                            <figcaption><b>Figure 14: Các class sẽ chọn implement những interface chưa các method mà nó cần thiết.</b></figcaption>
                        </figure>
                        <p class="caution rounded p-3">
                            <i class="fas fa-exclamation-circle"></i>
                            Mục tiêu của nguyên tắc này giúp tránh được những implement dư thừa. Tuy nhiên cần phải nhớ rằng chúng ta tách interface một cách hợp lý chứ không phải tách nhỏ. Vì nếu tách quá nhỏ thì số lượng interface gia tăng dẫn đến khó để kiểm soát ứng dụng.
                        </p>
                        <h2 id="dependency-inversion-principle" class="mt-4">5. Dependency Inversion Principle (DIP)</h2>
                        <p>Nguyên lý này có nội dung như sau: </p>
                        <blockquote class="quote rounded mt-3 p-3">
                            <ul>
                                <li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
                                <li>Abstractions should not depend on details. Details should depend on abstractions.</li>
                            </ul>
                            <hr>
                            <ul class="mb-0">
                                <li>Các module cấp cao không nên phụ thuộc vào các modules cấp thấp. Cả 2 nên phụ thuộc vào abstraction.</li>
                                <li>Abstractions không nên phụ thuộc vào chi tiết, mà ngược lại.</li>
                            </ul>
                        </blockquote>
                        <p>Với nguyên lý này chúng ta cần biết khái niệm như nào là <code>module cấp cao</code> và <code>module cấp thấp</code>.
                            Khi module A gọi module B, lúc này module A phụ thuộc (depend) vào module B. Thì module A là <code>module cấp cao</code> và module B là <code>module cấp thấp</code>.
                        </p>
                        <p>
                            Ví dụ với chức năng đăng ký tài khoản, sau khi đăng ký thành công chúng ta sẽ cần gửi email kick hoạt tài khoản. Trường hợp này thì <code>RegisterController</code> sẽ là module cấp cao và <code>GmailService</code> là module cấp thấp.
                        </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/dip_01.png" alt="Dependency Inversion Principle (DIP)">
                            <figcaption><b>Figure 15: Sau khi đăng ký tài khoản sẽ gửi email bằng Google mail service.</b></figcaption>
                        </figure>
                        <p>Việc module cấp cao gọi trực tiếp module cấp thấp như Figure 15 sẽ dẫn đến <code>RegisterController</code> bị phụ thuộc vào <code>GmailService</code>. Trong trường hợp ứng dụng thay đổi sử dụng dịch vụ Hot mail thay vì dùng Gmail thì lúc này <code>RegisterController</code> cần thay đổi gọi sang <code>HotMailService</code>.
                        Để giải quyết việc phụ thuộc này chúng ta sẽ thiết kế như sau:
                        </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/dip_02.png" alt="Dependency Inversion Principle (DIP)">
                            <figcaption><b>Figure 16: <code>RegisterController</code> sẽ liên kết trực tiếp đến interface <code>EmailService</code></b></figcaption>
                        </figure>
                        <p>Khi <code>RegisterController</code> sẽ liên kết trực tiếp đến interface <code>EmailService</code>, điều này sẽ giúp cho <code>RegisterController</code> sẽ có thể linh động sử dụng bất kì service email nào mà bản thân nó không phải thay đổi. </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/dip_03.png" alt="Dependency Inversion Principle (DIP)">
                            <figcaption><b>Figure 17: <code>RegisterController</code> sẽ không bị phụ thuộc vào 1 service mail cụ thể mà có thể linh động sử dụng</b></figcaption>
                        </figure>
<!--                        <p><a href="https://github.com/phuongdp-tech/demo-source-winzone-blog/blob/main/SQL/VIEW_IN_SQL.sql" target="_blank">Source code tham khảo</a></p>-->
                        <p>Ta có thể triển khai source code bằng cách <code>RegisterController</code> sẽ được inject EmailService thay vì trực tiếp <code>GmailService</code>: </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/dip_04.png" alt="Dependency Inversion Principle (DIP)">
                            <figcaption><b>Figure 18: <code>RegisterController</code> inject EmailService thay vì trực tiếp GmailService</b></figcaption>
                        </figure>
                        <p>Trong quá trình execute <code>RegisterController</code> có thể switch email service khác nhau mà bản thân nó không phải chỉnh sửa gì. </p>
                        <figure style="text-align: center;">
                            <img class="rounded p-2" src="../images/blog/19/dip_05.png" alt="Dependency Inversion Principle (DIP)">
                            <figcaption><b>Figure 19: <code>RegisterController</code> không cần chỉnh sửa khi đổi từ <code>GmailService</code> sang dùng <code>HotMailService</code></b></figcaption>
                        </figure>
                        <p class="caution rounded p-3">
                            <i class="fas fa-exclamation-circle"></i>
                            Cách triển khai code bên trên đang sử dụng Dependency Injection, một trong những cách implement Dependency Inversion Principle.
                        </p>
                        <h2 id="summary" class="mt-4">6. Kết luận</h2>
                        <p>Gửi lời khen ngợi đến các bạn đã kiên trì cùng mình hoàn thành nội dung liên quan đến 5 nguyên lý trong SOLID. Hi vọng sau bài viết này các bạn sẽ hiểu cơ bản về SOLID và áp dụng vào cách thiết kế để giúp source code của mình dễ dàng mở rộng hơn.</p>
                        <p>Tuy nhiên cũng cần phải lưu ý rằng, bất cứ nguyên lý nào cũng có 2 mặt lợi và hại. Nếu cứng nhắc áp dụng thì đôi khi source code sẽ bị dài dòng, phức tạp và khó quản lý hơn.
                           Nên bạn cần hiểu và áp dụng SOLID một cách hợp lý chứ không phải cứng nhắc.</p>
                    </div>
                </div>

                <div class="fb-comments mt-4" data-href="https://winzone.vn/post/what-is-the-solid-principle.html" data-width="100%" data-numposts="5"></div>
            </div>
        </div>
    </div><!--end container-->
</section><!--end section-->
<!-- Blog End -->

<footer id="footer-page"></footer>

<!-- javascript -->
<script src="../js/jquery-3.4.1.min.js"></script>
<script src="../js/bootstrap.bundle.min.js"></script>
<script src="../js/jquery.easing.min.js"></script>
<script src="../js/scrollspy.min.js"></script>
<!-- Icons -->
<script src="../js/feather.min.js"></script>
<script src="../js/unicons-monochrome.js"></script>

<!-- Main Js -->
<script src="../js/app.js"></script>
</body>
</html>
